# -*- coding: utf-8 -*-
"""0_EDA _Clustering Customer Personality Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BmxR-pq1fLidJS5fEpLC0GQ2quv2RlMw

#**Customer Personality Analysis**

**Acerca del conjunto de datos
Contexto
Planteamiento del problema**

El análisis de la personalidad del cliente es un análisis detallado de los clientes ideales de una empresa. Ayuda a las empresas a comprender mejor a sus clientes y facilita la adaptación de sus productos según las necesidades, comportamientos e inquietudes específicas de los diferentes tipos de clientes.

El análisis de la personalidad del cliente ayuda a una empresa a adaptar su producto en función de sus clientes objetivo de diferentes segmentos. Por ejemplo, en lugar de invertir en comercializar un nuevo producto a todos los clientes de su base de datos, una empresa puede analizar qué segmento de clientes tiene más probabilidades de comprarlo y comercializarlo únicamente a ese segmento en particular.

**Objetivo**
Es necesario realizar una agrupación para resumir los segmentos de clientes.

**Reconocimiento**
El conjunto de datos para este proyecto es proporcionado por el Dr. Omar Romero-Hernandez.

## Semana 1: Enmarcar el problema y Obtener los datos

### Proyecto Elegido: Customer Personality Analysis – Segmentación de Clientes

---

### **1. Enmarcar el problema**

#### 1.1 Objetivo de negocio

El objetivo principal de este proyecto es segmentar a los clientes de una empresa utilizando sus características demográficas, económicas y de comportamiento de compra. Mediante técnicas de *clustering*, se pretende identificar grupos de clientes con perfiles similares para:

- Mejorar la efectividad de las campañas de marketing.
- Diseñar estrategias comerciales personalizadas.
- Analizar la rentabilidad y el valor potencial de cada segmento.

#### 1.2 ¿Cómo se utilizará la solución?

- **Segmentación de mercado**: Agrupar a los clientes según sus patrones de consumo y datos personales.
- **Marketing dirigido**: Diseñar campañas específicas adaptadas a las necesidades de cada grupo.
- **Análisis estratégico**: Ayudar al equipo de marketing y ventas a comprender mejor el comportamiento del cliente.

#### 1.3 ¿Es supervisado o no supervisado?

Es un problema de **aprendizaje no supervisado**, ya que no se dispone de una variable objetivo. Se busca descubrir patrones ocultos sin etiquetas previas utilizando técnicas como K-Means o clustering jerárquico.

---

### **2. Obtener los datos**

#### 2.1 Fuente de datos

Los datos utilizados provienen de la plataforma Kaggle. Al ser de acceso público, no es necesario solicitar autorización para su uso.

- **Título del dataset**: *Customer Personality Analysis*
- **Fuente original**: [Kaggle - Customer Personality Analysis](https://www.kaggle.com/datasets/imakash3011/customer-personality-analysis)
- **Archivo original descargado**: `marketing_campaign.csv`
- **Archivo de trabajo utilizado**: `Customer_Personality.csv` (copia almacenada localmente)

---

## Semana 2: Análisis Exploratorio de Datos (EDA – Exploratory Data Analysis)

Durante esta fase se realizará un análisis exploratorio detallado del dataset. Se analizarán las distribuciones, tipos de variables, presencia de valores nulos y patrones ocultos. Este análisis es clave para:

- Comprender las características más influyentes de los clientes.
- Preparar los datos para una adecuada segmentación mediante *feature engineering*.
- Detectar outliers o inconsistencias que puedan afectar el modelo.

El análisis visual y estadístico servirá como base para el diseño del modelo de clustering en las próximas etapas.

# Resumen EDA – Customer Personality Clustering

---

## **1. Información General**

- **Total de registros:** 2.240  
- **Columnas iniciales:** 29  
- **Duplicados detectados (sin contar el ID):** 182  
- **Columnas con valores constantes:** 2 (`Z_CostContact` = 3, `Z_Revenue` = 11)  
- **Celdas con valores nulos:** 24 en `Income` (1.1%)

---

## **2. Variables demográficas clave**

- **Año de nacimiento (`Year_Birth`):**
  - Oscila entre 1893 y 1996
  - Algunos registros mayores a 100 años (posibles outliers)
  - Edad promedio estimada ≈ 56 años

- **Estado civil (`Marital_Status`):**
  - Principales: Married (864), Together (580), Single (480)
  - Categorías atípicas: “Alone”, “Absurd”, “YOLO” → agrupar como “Other”

- **Educación (`Education`):**
  - Dominan “Graduation” (1127), “PhD” (486), “Master” (370)
  - Menores proporciones en “2n Cycle” y “Basic”

---

## **3. Variables de comportamiento y consumo**

- **Gasto por tipo de producto (`MntWines`, `MntMeatProducts`, etc.):**
  - Alta correlación entre variables de gasto
  - Distribuciones sesgadas hacia la derecha
  - Se propone crear una variable resumen: `Total_Spent`

- **Canales de compra (`NumWebPurchases`, `NumCatalogPurchases`, etc.):**
  - Alta actividad en web y tienda física
  - `NumCatalogPurchases` tiene un 26.2% de ceros

- **`Recency`:**
  - Distribución completa (0–99 días)
  - Valores bajos implican mayor actividad reciente

---

## **4. Variables de respuesta a campañas**

- `AcceptedCmp1–5` y `Response` están muy desbalanceadas:
  - Más del 60% de los registros tienen valor 0
  - Recomendación: crear `Campaigns_Accepted` como resumen

- `Complain`: 92.3% de los clientes no se han quejado → variable poco útil para clustering general

---

## **5. Outliers y sesgo**

- Outliers detectados visualmente en:
  - `Income`, `MntWines`, `MntGoldProds`, `NumCatalogPurchases`
- Muchas variables tienen **valores extremos y distribución asimétrica**
- Se recomienda winsorización o log-transformación si se usan directamente

---

## **6. Correlación entre variables**

- Alta correlación entre:
  - Variables de gasto (`Mnt*`)
  - Variables de compra (`Num*Purchases`)
  - `Income` correlaciona con varias de ambas
- Puede ser útil aplicar **PCA** o eliminar redundancias antes del clustering

---

## **7. Observaciones adicionales**

- `Dt_Customer` debe convertirse a `datetime` → permite calcular antigüedad (`Customer_Since_Days`)
- `ID` no aporta valor analítico → eliminar antes de modelar

---

## Recomendaciones para preprocesamiento

- Eliminar duplicados (sin contar `ID`)
- Eliminar columnas constantes
- Tratar nulos en `Income` (recomendado: mediana)
- Tratar outliers si se usan variables originales
- Codificar variables categóricas (`Education`, `Marital_Status`)
- Crear nuevas variables:
  - Edad
  - Total hijos (`Kidhome + Teenhome`)
  - Gasto total (`Total_Spent`)
  - Campañas aceptadas (`Campaigns_Accepted`)
  - Antigüedad del cliente
- Escalar variables numéricas antes de aplicar clustering

---
"""

#@title **Importar librerías para Análisis Exploratorio de Datos (EDA)**

# Librerías esenciales para manejo y análisis de datos
import pandas as pd  # Procesamiento, análisis y limpieza de datos
import numpy as np  # Cálculos numéricos y manipulación de arreglos

# Librerías para visualización de datos
import matplotlib.pyplot as plt  # Gráficos y visualizaciones personalizadas
import seaborn as sns  # Visualizaciones estadísticas atractivas y eficientes

# Librerías adicionales para análisis dimensional y clustering
from sklearn.preprocessing import LabelEncoder, StandardScaler  # Preparación de variables
from sklearn.decomposition import PCA  # Análisis de componentes principales
from sklearn.cluster import KMeans, AgglomerativeClustering  # Algoritmos de agrupamiento
from sklearn import metrics  # Evaluación de modelos de clustering

# Librerías para visualización de clustering y gráficas 3D
from yellowbrick.cluster import KElbowVisualizer  # Visualización del número óptimo de clusters
from mpl_toolkits.mplot3d import Axes3D  # Gráficos tridimensionales
from matplotlib.colors import ListedColormap, Normalize  # Paletas de colores personalizadas

# Evitar que aparezcan advertencias en la ejecución
import warnings, sys
if not sys.warnoptions:
    warnings.simplefilter("ignore")

# Fijar semilla para reproducibilidad
np.random.seed(42)

# Instalar y cargar herramienta de EDA automatizada
!pip install ydata-profiling
from ydata_profiling import ProfileReport  # Generación automática de informes EDA

"""##**Explorar los datos para obtener información (Análisis de datos no grafico)**

Para empezar que tipos de datos contiene el archivo a analizar, se realizaran unas visualizaciones en forma tabla para ver su contenido, asi como sí hay valores nulos, etc.
"""

#@title **Cargar datos:**
#Crear DataFrame desde csv y usar comando para leer el CSV descargado y guardado en el Colab.

df_Customer_Personality= pd.read_csv("Customer_Personality.csv",sep='\t')

#@title Visualización Tabla
# Con la función head se muestra las 5 primeras filas del archivo.
df_Customer_Personality.head()

"""## Información del Dataset: Customer Personality Analysis

Este dataset contiene información detallada sobre los clientes de una empresa, incluyendo aspectos demográficos, comportamiento de compra, respuesta a campañas de marketing y patrones de consumo. La información se puede agrupar en varias categorías:

| Categoría                           | Variable              | Descripción                                                                 |
|------------------------------------|------------------------|------------------------------------------------------------------------------|
| Información del cliente            | ID                     | Identificador único del cliente                                              |
|                                    | Year_Birth             | Año de nacimiento del cliente                                                |
|                                    | Education              | Nivel de educación del cliente                                               |
|                                    | Marital_Status         | Estado civil del cliente                                                     |
|                                    | Income                 | Ingresos familiares anuales del cliente                                      |
|                                    | Kidhome                | Número de niños en el hogar del cliente                                      |
|                                    | Teenhome               | Número de adolescentes en el hogar del cliente                               |
|                                    | Dt_Customer            | Fecha de alta del cliente en la empresa                                      |
|                                    | Recency               | Días desde la última compra del cliente                                      |
|                                    | Complain               | 1 = quejó en los últimos 2 años, 0 = no se quejó                             |
| Productos consumidos (últimos 2 años) | MntWines             | Cantidad gastada en vino                                                     |
|                                    | MntFruits              | Cantidad gastada en frutas                                                   |
|                                    | MntMeatProducts        | Cantidad gastada en carne                                                    |
|                                    | MntFishProducts        | Cantidad gastada en pescado                                                  |
|                                    | MntSweetProducts       | Cantidad gastada en dulces                                                   |
|                                    | MntGoldProds           | Cantidad gastada en oro                                                      |
| Respuesta a promociones            | NumDealsPurchases      | Número de compras realizadas con descuento                                   |
|                                    | AcceptedCmp1-5         | 1 = aceptó campaña correspondiente, 0 = no la aceptó                         |
|                                    | Respuesta              | 1 = aceptó última campaña, 0 = no la aceptó                                  |
| Canales de compra                  | NumWebPurchases        | Compras realizadas a través del sitio web                                    |
|                                    | NumCatalogPurchases    | Compras realizadas mediante catálogo                                         |
|                                    | NumStorePurchases      | Compras realizadas en tiendas físicas                                        |
|                                    | NumWebVisitsMonth      | Número de visitas al sitio web en el último mes                              |

"""

#@title Resumen estadistico general

df_Customer_Personality.describe().T

#@title Info de tipo de datos, nulos, etc.
df_Customer_Personality.info()

#@title Valores Nulos
# Comprobar valores nulos True o False con el .sum te hara la suma del True, es decir sumara 1
#sacara la suma de los nulos
print(df_Customer_Personality.isnull().sum())

#@title Verificar si hay filas duplicadas

print(f'Número de filas duplicadas df_base: {df_Customer_Personality.duplicated().sum()}')

#title Valores unicos columna CustomerID
#Este código cuenta el número de valores únicos en la columna "CustomerId".

len(df_Customer_Personality['ID'].unique()) # solo si hay columna id

#@title Verifica si hay IDs duplicados
print(f'Número de IDs duplicados:{df_Customer_Personality["ID"].duplicated().sum()}')

#@title Verifica duplicados sin considerar el ID
duplicados_sin_id = df_Customer_Personality.drop(columns=['ID']).duplicated().sum()
print(f'Duplicados sin contar ID: {duplicados_sin_id}')

#@title Distribución de las variables (solo columnas categóricas seleccionadas)

# Seleccionamos directamente las columnas categóricas deseadas
obj_cols = df_Customer_Personality[['Education', 'Marital_Status']]

# Iteramos por cada columna categórica seleccionada
for col in obj_cols:
    conteo = obj_cols[col].value_counts().reset_index()
    conteo.columns = [col.capitalize(), '']
    display(conteo.style.set_caption('').hide(axis='index'))

#@title valores únicos hay en cada columna del DataFrame
print(df_Customer_Personality.nunique())

"""#**Análisis univariado**
Objetivo: entender la distribución de cada variable.

**Variables categóricas**:
Education, Marital_Status, Complain, Response, AcceptedCmp1-5
"""

#import matplotlib.pyplot as plt
#import seaborn as sns

categorical = ['Education', 'Marital_Status', 'Complain', 'Response',
               'AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3',
               'AcceptedCmp4', 'AcceptedCmp5']

paletas = ['pastel', 'muted', 'Set2', 'husl', 'coolwarm',
           'Blues', 'Reds', 'Greens', 'Oranges']

fig, axes = plt.subplots(3, 3, figsize=(18, 12))
axes = axes.flatten()
total = len(df_Customer_Personality)

for i, col in enumerate(categorical):
    ax = axes[i]
    order = df_Customer_Personality[col].value_counts().index

    sns.countplot(data=df_Customer_Personality, x=col, hue=col,
                  palette=paletas[i % len(paletas)], order=order,
                  legend=False, ax=ax)

    ax.set_title(f'Distribución de {col}')
    ax.tick_params(axis='x', rotation=45)

    for p in ax.patches:
        count = int(p.get_height())
        pct = f"{100 * count / total:.1f}%"
        ax.annotate(pct, (p.get_x() + p.get_width()/2, p.get_height()),
                    ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

"""#**Variables numéricas:**
Year_Birth, Income, Recency, MntWines, NumWebPurchases, etc.
"""

#import matplotlib.pyplot as plt

numerical = ['Year_Birth', 'Income', 'Recency', 'NumWebPurchases',
             'MntWines', 'MntFruits', 'MntMeatProducts',
             'MntFishProducts', 'MntSweetProducts', 'MntGoldProds',
             'NumCatalogPurchases', 'NumStorePurchases']  # Añadí dos más si quieres una rejilla 3x4

# Crear figura y ejes: 3 filas x 4 columnas
fig, axes = plt.subplots(3, 4, figsize=(20, 12))
axes = axes.flatten()  # Para recorrerlos fácilmente

# Dibujar un histograma para cada variable
for i, col in enumerate(numerical):
    ax = axes[i]
    ax.hist(df_Customer_Personality[col].dropna(), bins=20, color='skyblue', edgecolor='gray')
    ax.set_title(f'Distribución de {col}', fontsize=12)
    ax.grid(True)

# Eliminar ejes vacíos si hay menos de 12 gráficas
for j in range(len(numerical), len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""**#Análisis bivariado**
Objetivo: ver relaciones entre variables.

Correlaciones numéricas:
"""

plt.figure(figsize=(12, 10))
sns.heatmap(df_Customer_Personality[numerical].corr(), annot=True, cmap='coolwarm')
plt.title("Mapa de calor de correlaciones")
plt.show()

#@title ¿La edad influye en el gasto?

# Crear columna de edad (si aún no existe)
df_Customer_Personality['Age'] = 2025 - df_Customer_Personality['Year_Birth']

# Estilo general del gráfico
sns.set(style='whitegrid', palette='muted')

# Figura con 1 fila y 2 columnas
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# Gráfico 1: Edad vs Ingreso
sns.scatterplot(data=df_Customer_Personality, x='Age', y='Income', ax=axes[0],
                color='steelblue', edgecolor='black', alpha=0.6)
axes[0].set_title('Edad vs Ingreso', fontsize=14)
axes[0].set_xlabel('Edad')
axes[0].set_ylabel('Ingreso (€)')

# Gráfico 2: Edad vs Gasto en Vino
sns.scatterplot(data=df_Customer_Personality, x='Age', y='MntWines', ax=axes[1],
                color='indianred', edgecolor='black', alpha=0.6)
axes[1].set_title('Edad vs Gasto en Vino', fontsize=14)
axes[1].set_xlabel('Edad')
axes[1].set_ylabel('Gasto en Vino (€)')

plt.tight_layout()
plt.show()

# Detectar outliers o valor atípico

# Aseguramos que la columna 'Age' esté creada
df_Customer_Personality['Age'] = 2025 - df_Customer_Personality['Year_Birth']

# Variables numéricas que quieres analizar
numeric_features = ['Age', 'Income', 'Recency', 'NumWebPurchases',
                    'MntWines', 'MntFruits', 'MntMeatProducts',
                    'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']

# Crear la figura: 2 filas x 5 columnas
plt.figure(figsize=(20, 8))

# Graficar un boxplot por variable
for i, feature in enumerate(numeric_features, 1):
    plt.subplot(2, 5, i)
    sns.boxplot(y=df_Customer_Personality[feature], color='lightblue', fliersize=4)
    plt.title(f'Boxplot de {feature}')
    plt.grid(True)

plt.tight_layout()
plt.show()

#@title Variables combinadas
#Esto es útil para generar futuras features:
df_Customer_Personality['Total_Spent'] = df_Customer_Personality[
    ['MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']
].sum(axis=1)

df_Customer_Personality['Children'] = df_Customer_Personality['Kidhome'] + df_Customer_Personality['Teenhome']

# Asegurar que las columnas existen
df_Customer_Personality['Total_Spent'] = df_Customer_Personality[
    ['MntWines', 'MntFruits', 'MntMeatProducts',
     'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']
].sum(axis=1)

df_Customer_Personality['Children'] = df_Customer_Personality['Kidhome'] + df_Customer_Personality['Teenhome']

plt.figure(figsize=(10, 6))

# Aplicamos hue=x y legend=False para evitar el warning
sns.boxplot(
    data=df_Customer_Personality,
    x='Children',
    y='Total_Spent',
    hue='Children',
    palette='Set2',
    legend=False
)

plt.title('Gasto total por número de hijos en el hogar', fontsize=14)
plt.xlabel('Número de hijos (Kidhome + Teenhome)')
plt.ylabel('Gasto total (€)')
plt.grid(True)
plt.tight_layout()
plt.show()

#@title **EDA Automático con ydata-profiling**

# Instalar la librería (si no está instalada)
#!pip install ydata-profiling

# Importar la librería
#from ydata_profiling import ProfileReport

# Eliminamos la primera columna del DataFrame (ID)
# ya que no aporta información relevante para el análisis
# hara una copia del original llamado df_filtrado_Seg_clientes
df_filtrado_Customer_Personality = df_Customer_Personality.iloc[:, 1:]

# Creamos el informe de análisis exploratorio con un título descriptivo
profile = ProfileReport(df_filtrado_Customer_Personality, title="Reporte de Análisis Exploratorio de Datos", explorative=True)

# Mostramos el informe dentro de Google Colab
profile.to_notebook_iframe()

"""# Resumen de Alertas – Análisis Automático (`pandas_profiling`)

---

## 1. Columnas constantes (sin variación)

- `Z_CostContact`: todos los valores son "3"
- `Z_Revenue`: todos los valores son "11"

> Acción recomendada: eliminar ambas columnas, no aportan información para el modelo.

---

## 2. Filas duplicadas

- 176 registros duplicados (7.9% del total), incluyendo todas las columnas
- Confirmado que `ID` no se repite, pero el resto de los valores sí

> Acción recomendada: eliminar duplicados manteniendo solo una fila por combinación única de variables (excepto ID).

---

## 3. Correlación excesiva entre variables

- Variables altamente correlacionadas con `Income` (y entre sí):
  - `MntFishProducts`, `MntFruits`, `MntGoldProds`, `MntMeatProducts`, `MntSweetProducts`, `MntWines`
  - `NumCatalogPurchases`, `NumStorePurchases`, `NumWebPurchases`, `NumWebVisitsMonth`

- `MntWines` también correlaciona fuertemente con `AcceptedCmp5`

> Implicación:
- Puede causar **redundancia en clustering**
- Se recomienda **crear variables agregadas** (como `Total_Spent`, `Total_Purchases`) o aplicar **PCA**

---

## 4. Variables desbalanceadas

Variables binarias con distribución muy inclinada hacia el valor 0:

| Variable         | % de ceros |
|------------------|------------|
| AcceptedCmp1     | 65.6%      |
| AcceptedCmp2     | 89.7%      |
| AcceptedCmp3     | 62.4%      |
| AcceptedCmp4     | 61.7%      |
| AcceptedCmp5     | 62.4%      |
| Complain         | 92.3%      |

> Implicación:
- Poca variabilidad → **aportan poco valor al clustering**
- Recomendado: combinarlas en una sola variable (`Campaigns_Accepted`) o descartarlas

---

## 5. Valores faltantes

- `Income`: 24 valores nulos (1.1%)

> Acción recomendada: imputar con la mediana para evitar sesgo por outliers

---

## 6. Presencia de ceros significativos

Variables con alto número de ceros que podrían indicar **clientes inactivos**:

| Variable              | % de ceros |
|-----------------------|------------|
| Recency               | 1.2%       |
| MntFruits             | 17.9%      |
| MntFishProducts       | 17.1%      |
| MntSweetProducts      | 18.7%      |
| MntGoldProds          | 2.7%       |
| NumDealsPurchases     | 2.1%       |
| NumWebPurchases       | 2.2%       |
| NumCatalogPurchases   | 26.2%      |

> Implicación:
- Ceros pueden representar **clientes inactivos** o **sin interés** en ciertos productos
- Es útil para el clustering (segmentos de baja actividad)

---

## Conclusiones de limpieza a realizar según las alertas

- [ ] Eliminar columnas constantes
- [ ] Eliminar duplicados
- [ ] Imputar `Income` (mediana)
- [ ] Agrupar campañas aceptadas
- [ ] Crear variables resumen para reducir correlación
- [ ] Conservar ceros como indicadores de comportamiento

---

"""